import { getRequestEvent, query } from '$app/server';
import { fetchLandingPageWordsTreeNode } from '$lib/server/words/fetch_landing_page_words_tree/fetch_landing_page_words_tree';
import z from 'zod';

import { GoogleGenAI } from '@google/genai';
import { stringifyIt } from '$lib/utils';

const ai = new GoogleGenAI({});

//import uuidValidate from 'uuid-validate';

export const fetchLandingPageWordsTreeNodeRemote = query(z.string(), async (categoryKey) => {
	/*if (!uuidValidate(categoryKey)) {
		const errObj = {
			errorCode: 'INVALID_CATEGORY_KEY_UUID',
			errorMessage: 'The provided category key is not a valid UUID.'
		};
		return Promise.reject(errObj);
	}*/

	const { locals } = getRequestEvent();

	const db = locals.db;

	const landingPageWordsTreeNode = await fetchLandingPageWordsTreeNode({
		db: db,
		categoryKey: categoryKey
	});

	return landingPageWordsTreeNode;
});

export const makeSentencesFromWordsRemote = query(z.array(z.string()), async (words) => {
	const makeGeminiMakeSentencesFromWordsRes = await makeGeminiMakeSentencesFromWords(words);
	return makeGeminiMakeSentencesFromWordsRes;
});

const geminiAPIPromptResponseSchema = z.array(
	z.object({
		sentence: z.string(),
		language: z.string()
	})
);

export type MakeGeminiMakeSentencesFromWordsRes = {
	sentences: {
		sentence: string;
		language: string;
	}[];
	fullPrompt: string;
	error: null | {
		errorType:
			| 'GEMINI_API_NO_RESPONSE_TEXT'
			| 'GEMINI_API_RESPONSE_TEXT_JSON_PARSE_ERROR'
			| 'GEMINI_API_RESPONSE_PARSING_ERROR'
			| 'GEMINI_API_SERVICE_UNAVAILABLE_503'
			| 'GEMINI_API_SERVICE_UNAVAILABLE_429'
			| 'GEMINI_API_GENERATE_CONTENT_ERROR';
		//errObj: unknown;
		errString: string;
		responseText: string | null;
	};
};

const makeGeminiMakeSentencesFromWords = async (
	words: string[]
): Promise<MakeGeminiMakeSentencesFromWordsRes> => {
	const wordsWithQuotes = words.map((word) => `"${word}"`).join(', ');
	const geminiMakeSentencesFromWordsPrompt1 = `Make sentences from the words ${wordsWithQuotes}.`;
	const geminiMakeSentencesFromWordsPrompt2 = `The words are names, places, concepts etc try to make a meaningful sentence from them.`;
	const geminiMakeSentencesFromWordsPrompt3 = `The sentences generated by someone who has lost speech, so it's from first person and succint. Only work with the words provided. You can add some verbs to construct natural sentences.`;
	const geminiMakeSentencesFromWordsPrompt4 = `Make the sentences in English and Swahili.`;
	const geminiMakeSentencesFromWordsPrompt5 = `Return the sentences in a JSON array in the following format: [{ sentence: '...', language: 'en' | 'sw' }].`;
	const geminiMakeSentencesFromWordsPrompt6 = `Make sure the JSON is properly formatted, should work on JSON.parse.`;
	const fullPrompt = `${geminiMakeSentencesFromWordsPrompt1} ${geminiMakeSentencesFromWordsPrompt2} ${geminiMakeSentencesFromWordsPrompt3} ${geminiMakeSentencesFromWordsPrompt4} ${geminiMakeSentencesFromWordsPrompt5} ${geminiMakeSentencesFromWordsPrompt6}`;

	try {
		const response = await ai.models.generateContent({
			model: 'gemini-3-flash-preview',
			contents: fullPrompt
		});

		//for now we'll use use this, eventually we'll learn the API
		const responseTextInitial = response.text;

		//if responseText is falsy, return error
		if (!responseTextInitial) {
			return {
				sentences: [],
				fullPrompt: fullPrompt,
				error: {
					errorType: 'GEMINI_API_NO_RESPONSE_TEXT',
					errString: 'No response text received from Gemini API.',
					responseText: responseTextInitial ? responseTextInitial : null
				}
			};
		}

		//attempt to remove '```json' garbase

		const responseText = removeJSONHeaderGarbage(responseTextInitial);

		//wrap the JSON.parse in try catch
		let responseTextJSONParse;
		try {
			responseTextJSONParse = JSON.parse(responseText);
		} catch (jsonParseErrGeminiResponse) {
			console.log('JSON parse error:', responseText);

			return {
				sentences: [],
				fullPrompt: fullPrompt,
				error: {
					errorType: 'GEMINI_API_RESPONSE_TEXT_JSON_PARSE_ERROR',
					//errObj: jsonParseErr,
					errString: stringifyIt(jsonParseErrGeminiResponse),
					responseText: responseText
				}
			};
		}

		//safely parse the response
		const parsedResponse = geminiAPIPromptResponseSchema.safeParse(responseTextJSONParse);
		if (parsedResponse.success) {
			//happy path!!
			return {
				sentences: parsedResponse.data,
				fullPrompt: fullPrompt,
				error: null
			};
		}

		//it gets here that's a parsing error or bad response from gemini
		return {
			sentences: [],
			fullPrompt: fullPrompt,
			error: {
				errorType: 'GEMINI_API_RESPONSE_PARSING_ERROR',
				//errObj: parsedResponse.error,
				errString: stringifyIt(parsedResponse.error),
				responseText: responseText
			}
		};
	} catch (geminiGenerateContentErr) {
		const errString = stringifyIt(geminiGenerateContentErr);

		//if error has 503
		if (errString.includes('503')) {
			return {
				sentences: [],
				fullPrompt: fullPrompt,
				error: {
					errorType: 'GEMINI_API_SERVICE_UNAVAILABLE_503',
					errString: errString,
					responseText: null
				}
			};
		}

		//if 429
		if (errString.includes('429')) {
			return {
				sentences: [],
				fullPrompt: fullPrompt,
				error: {
					errorType: 'GEMINI_API_SERVICE_UNAVAILABLE_429',
					errString: 'Rate limit exceeded (429)',
					responseText: null
				}
			};
		}

		return {
			sentences: [],
			fullPrompt: fullPrompt,
			error: {
				errorType: 'GEMINI_API_GENERATE_CONTENT_ERROR',
				//errObj: geminiGenerateContentErr,
				errString: errString,
				responseText: 'unknown'
			}
		};
	}
};

const removeJSONHeaderGarbage = (responseText: string): string => {
	return responseText.replace(/```json|```/g, '').trim();
};
